import { createTextVNode as _createTextVNode, mergeProps as _mergeProps, Fragment as _Fragment, createVNode as _createVNode } from "vue";
// Styles
import "./VSelect.css"; // Components

import { VChip } from "../VChip/index.mjs";
import { VIcon } from "../VIcon/index.mjs";
import { VList, VListItem } from "../VList/index.mjs";
import { VMenu } from "../VMenu/index.mjs";
import { VTextField } from "../VTextField/index.mjs"; // Composables

import { makeFilterProps, useFilter } from "../../composables/filter.mjs";
import { useForwardRef } from "../../composables/forwardRef.mjs";
import { useLocale } from "../../composables/locale.mjs";
import { useProxiedModel } from "../../composables/proxiedModel.mjs"; // Utility

import { computed, ref, watch } from 'vue';
import { genericComponent, useRender, wrapInArray } from "../../util/index.mjs"; // Types

export const VSelect = genericComponent()({
  name: 'VSelect',
  props: {
    chips: Boolean,
    hideNoData: Boolean,
    hideSelected: Boolean,
    items: {
      type: Array,
      default: () => []
    },
    modelValue: {
      type: [Number, String, Array],
      default: () => []
    },
    multiple: Boolean,
    noDataText: {
      type: String,
      default: '$vuetify.noDataText'
    },
    openOnClear: Boolean,
    ...makeFilterProps()
  },
  emits: {
    'click:clear': e => true,
    'update:modelValue': val => true
  },

  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      t
    } = useLocale();
    const vTextFieldRef = ref();
    const activator = ref();
    const model = useProxiedModel(props, 'modelValue', [], v => wrapInArray(v), v => props.multiple ? v : v[0]);
    const {
      filteredItems
    } = useFilter(props, props.items);
    const menu = ref(false);
    const active = computed({
      get: () => model.value,
      set: val => {
        model.value = val;
        if (props.multiple) return;
        menu.value = false;
      }
    });
    const items = computed(() => {
      const array = [];

      for (const {
        item
      } of filteredItems.value) {
        var _item$title, _item$value;

        const title = (_item$title = item == null ? void 0 : item.title) != null ? _item$title : String(item);
        const value = (_item$value = item == null ? void 0 : item.value) != null ? _item$value : item;

        if (props.hideSelected && active.value.includes(value)) {
          continue;
        }

        array.push({
          title,
          value
        });
      }

      if (!array.length && !props.hideNoData) {
        array.push({
          title: t(props.noDataText)
        });
      }

      return array;
    });
    const selections = computed(() => {
      return items.value.filter(item => active.value.includes(item.value));
    });

    function onClear(e) {
      active.value = [];

      if (props.openOnClear) {
        menu.value = true;
      }
    }

    function onKeydown(e) {
      if (['Enter', ' '].includes(e.key) && !menu.value) {
        menu.value = true;
      }

      if (e.key === 'Escape' && menu.value) {
        menu.value = false;
      }
    }

    watch(() => vTextFieldRef.value, val => {
      activator.value = val.$el.querySelector('.v-input__control');
    });
    useRender(() => {
      return _createVNode(VTextField, _mergeProps({
        "ref": vTextFieldRef,
        "class": ['v-select', {
          'v-select--active-menu': menu.value,
          'v-select--chips': !!props.chips
        }],
        "readonly": true,
        "onClick:clear": onClear,
        "onClick:control": () => menu.value = true,
        "onBlur": () => menu.value = false,
        "modelValue": model.value.join(', '),
        "onKeydown": onKeydown
      }, attrs), { ...slots,
        appendInner: () => _createVNode(VIcon, {
          "class": "v-select__menu-icon",
          "icon": "mdi-menu-down"
        }, null),
        default: () => _createVNode(_Fragment, null, [activator.value && _createVNode(VMenu, {
          "modelValue": menu.value,
          "onUpdate:modelValue": $event => menu.value = $event,
          "activator": activator.value,
          "contentClass": "v-select__content",
          "openOnClick": false
        }, {
          default: () => [_createVNode(VList, {
            "active": active.value,
            "onUpdate:active": $event => active.value = $event,
            "items": items.value,
            "activeStrategy": props.multiple ? 'multiple' : 'single'
          }, {
            item: item => {
              return _createVNode(VListItem, _mergeProps({
                "onMousedown": e => e.preventDefault()
              }, item), null);
            }
          })]
        }), selections.value.length > 0 && _createVNode("div", {
          "class": "v-select__selections v-field__input"
        }, [selections.value.map((selection, index) => _createVNode("div", {
          "class": "v-select__selection"
        }, [props.chips ? _createVNode(VChip, {
          "text": selection.title,
          "size": "small"
        }, null) : _createVNode("span", {
          "class": "v-select__selection-text"
        }, [selection.title, index < model.value.length - 1 && _createVNode("span", {
          "class": "v-select__selection-comma"
        }, [_createTextVNode(",")])])]))])])
      });
    });
    return useForwardRef({//
    }, vTextFieldRef);
  }

});
//# sourceMappingURL=VSelect.mjs.map