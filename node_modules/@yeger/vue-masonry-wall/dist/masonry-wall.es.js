import { defineComponent, toRefs, ref, onMounted, onBeforeUnmount, watch, openBlock, createElementBlock, normalizeStyle, unref, Fragment, renderList, renderSlot, createTextVNode, toDisplayString, nextTick } from "vue";
const _hoisted_1 = ["data-index"];
const _sfc_main = /* @__PURE__ */ defineComponent({
  props: {
    columnWidth: { default: 400 },
    items: null,
    gap: { default: 0 },
    rtl: { type: Boolean, default: false },
    ssrColumns: { default: 0 }
  },
  emits: ["redraw", "redraw-skip"],
  setup(__props, { emit }) {
    const props = __props;
    const { columnWidth, items, gap, rtl, ssrColumns } = toRefs(props);
    const columns = ref([]);
    const wall = ref();
    function columnCount() {
      const count = Math.floor((wall.value.getBoundingClientRect().width + gap.value) / (columnWidth.value + gap.value));
      return count > 0 ? count : 1;
    }
    function createColumns(count) {
      return [...new Array(count)].map(() => []);
    }
    if (ssrColumns.value > 0) {
      const newColumns = createColumns(ssrColumns.value);
      items.value.forEach((_, i) => newColumns[i % ssrColumns.value].push(i));
      columns.value = newColumns;
    }
    async function fillColumns(itemIndex) {
      if (itemIndex >= items.value.length) {
        return;
      }
      await nextTick();
      const columnDivs = [...wall.value.children];
      if (rtl.value) {
        columnDivs.reverse();
      }
      const target = columnDivs.reduce((prev, curr) => curr.getBoundingClientRect().height < prev.getBoundingClientRect().height ? curr : prev);
      columns.value[+target.dataset.index].push(itemIndex);
      await fillColumns(itemIndex + 1);
    }
    async function redraw(force = false) {
      if (columns.value.length === columnCount() && !force) {
        emit("redraw-skip");
        return;
      }
      columns.value = createColumns(columnCount());
      const scrollY = window.scrollY;
      await fillColumns(0);
      window.scrollTo({ top: scrollY });
      emit("redraw");
    }
    const resizeObserver = new ResizeObserver(() => redraw());
    onMounted(() => {
      redraw();
      resizeObserver.observe(wall.value);
    });
    onBeforeUnmount(() => resizeObserver.unobserve(wall.value));
    watch([items, rtl], () => redraw(true));
    watch([columnWidth, gap], () => redraw());
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        ref_key: "wall",
        ref: wall,
        class: "masonry-wall",
        style: normalizeStyle({ display: "flex", gap: `${unref(gap)}px` })
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(columns.value, (column, columnIndex) => {
          return openBlock(), createElementBlock("div", {
            key: columnIndex,
            class: "masonry-column",
            "data-index": columnIndex,
            style: normalizeStyle({
              display: "flex",
              "flex-basis": 0,
              "flex-direction": "column",
              "flex-grow": 1,
              height: ["-webkit-max-content", "-moz-max-content", "max-content"],
              gap: `${unref(gap)}px`
            })
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(column, (itemIndex) => {
              return openBlock(), createElementBlock("div", {
                key: itemIndex,
                class: "masonry-item"
              }, [
                renderSlot(_ctx.$slots, "default", {
                  item: unref(items)[itemIndex],
                  index: itemIndex
                }, () => [
                  createTextVNode(toDisplayString(unref(items)[itemIndex]), 1)
                ])
              ]);
            }), 128))
          ], 12, _hoisted_1);
        }), 128))
      ], 4);
    };
  }
});
const MasonryWall = /* @__PURE__ */ (() => {
  const installable = _sfc_main;
  installable.install = (app) => {
    app.component("MasonryWall", installable);
  };
  return installable;
})();
export { MasonryWall as default };
